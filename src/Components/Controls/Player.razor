@using Microsoft.FluentUI.AspNetCore.Components
@using Microsoft.Extensions.Localization
@using Microsoft.Extensions.Options
@using PCRadio.DataAccess.Interfaces
@using PCRadio.Services
@using System.Globalization
@using System.Text.Json.Serialization
@using _regular = Microsoft.FluentUI.AspNetCore.Components.Icons.Regular
@using _filled = Microsoft.FluentUI.AspNetCore.Components.Icons.Filled
@using PCRadio.DataAccess.Models
@using PCRadio.Extensions
@using PCRadio.Services.Interfaces
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject IOptions<AppSettings> options
@inject IStations stations
@inject ILinkOpeningService linkOpeningService
@inject IStringLocalizer<Player> localizer
@inject HttpClient httpClient
@inject IHistoryRecords historyRecords
@inject IAppStateService appStateService
@inject IToastService toastService

<FluentStack Orientation="Orientation.Horizontal" Class="player">
    <img class="logo" src="@Station?.Logo" alt="@Station?.Name" loading="lazy" />
    <div style="min-width: 462px;">
        <div style="font-weight: bold;">@Station?.GetCountryIcon() @Station?.Name <span
                style="font-weight: normal;">(@_country @_cities)</span> </div>
        <div style="font-style: italic;">@_genres @_subgenres</div>
        <div title="@Station?.Description" style="font-size: 12px;height:36px;overflow: hidden;">
            @Station?.Description
        </div>
        <marquee id="NowPlaying" direction="left" behavior="scroll" scrollamount="2"
            style="color:var(--accent-fill-rest);font-size: 12px;@(string.IsNullOrEmpty(SearchText) ? "display: none;" : "")">
        </marquee>
    </div>
    <FluentSpacer />
    <div style="margin-left:2px;">
        <div>
            <FluentButton Id="popoverButton" IconStart="@(new _regular.Size24.Speaker2())" Color="Color.Accent"
                OnClick="@(() => _isPopoverVisible = !_isPopoverVisible)" Title="@localizer["Volume"]" />
        </div>
        <div>
            <FluentButton Id="btnSearch" IconStart="@(new _regular.Size24.VideoClip())" Color="Color.Accent"
                OnClick="@Search" Disabled="@(string.IsNullOrEmpty(SearchText))"
                Title="@localizer["SearchInYoutube"]" />
        </div>
    </div>

    <div style="margin-left:2px;margin-right: 20px;">
        <div>
            <FluentButton IconStart="@(_isPlaying ? new _regular.Size24.Pause() : new _regular.Size24.Play())"
                Color="Color.Accent" OnClick="@Play" Title="@localizer["PlayStop"]" />
        </div>
        <div>
            <FluentButton IconStart="@(Station!.IsFavorite ? new _filled.Size24.Heart() : new _regular.Size24.Heart())"
                Color="Color.Accent" OnClick="@ToggleFavorite" Title="@localizer["AddToFavorites"]" />
        </div>
    </div>
</FluentStack>
<FluentPopover AnchorId="popoverButton" @bind-Open="_isPopoverVisible" Style="width: 90px; height: 260px;"
    VerticalPosition="VerticalPosition.Top" HorizontalPosition="HorizontalPosition.Left">

    <Body>
        <FluentSlider Orientation="Orientation.Vertical" Min="0.0" Max="1.0" Step="0.01" ValueChanged="@SetVolume"
            Value="@(1.0 - _volume)" TValue="double" Style="width: 30px; height: 200px;">
            <FluentSliderLabel Position="1.0">0%</FluentSliderLabel>
            <FluentSliderLabel Position="0.75">25%</FluentSliderLabel>
            <FluentSliderLabel Position="0.5">50%</FluentSliderLabel>
            <FluentSliderLabel Position="0.25">75%</FluentSliderLabel>
            <FluentSliderLabel Position="0.0">100%</FluentSliderLabel>
        </FluentSlider>
    </Body>
</FluentPopover>
<audio id="audio" src="@AudioUrl" controls style="display: none;" onerror="@ShowMessage" onstalled="@ShowMessage" />
<script>
    var intervalId;

    function setMarquee(value) {
        var marquee = document.getElementById("NowPlaying");
        if (marquee.innerHTML != value) {
            marquee.innerHTML = value;
        }
    }

    window.setPageRef = (dotNetRef) => {
        window.getCurrentTrackName = () => {
            var player = document.getElementById("audio");
            if (player.src && !player.paused) {
                var name = player.src.split("/")[3];
                name = name.substring(0, name.indexOf("-"));
                dotNetRef.invokeMethodAsync('Ping', name).then(result => {
                    setMarquee(result);
                });
            }
            else {
                setMarquee("");
            }
        };
        intervalId = setInterval(getCurrentTrackName, 5000);
    };

    function playAudio(isPlaying) {
        var player = document.getElementById("audio");
        if (player) {
            if (isPlaying && player.paused) {
                player.play();
            } else if (!isPlaying && !player.paused) {
                player.pause();
            }
        }
    }

    function setVolume(volume) {
        var player = document.getElementById("audio");
        player.volume = volume;
    }

</script>

@code {
    [Parameter]
    public int? StationId { get; set; }

    private bool _isPlaying;
    private string? _country;
    private string? _cities;
    private string? _genres;
    private string? _subgenres;
    private string? _searchText = string.Empty;
    private string? SearchText
    {
        get => _searchText;
        set
        {
            if (_searchText != value)
            {
                _searchText = value;
                StateHasChanged();
            }
        }
    }
    private double _volume = 0.5;
    private bool _isPopoverVisible;
    private Station? Station { get; set; }
    private DotNetObjectReference<Player>? thisRef;
    private HistoryRecordEqualityComparer historyRecordEqualityComparer = new HistoryRecordEqualityComparer();
    string AudioUrl => $"{Station?.Stream}-{options.Value.GetQuality()}";
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            thisRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setPageRef", thisRef);
        }

        await JSRuntime.InvokeVoidAsync("playAudio", _isPlaying);
        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnParametersSetAsync()
    {
        if (StationId.HasValue && Station?.Id != StationId.Value)
        {
            SearchText = string.Empty;
            Station = stations.GetStation(StationId.Value);
            _country = Station?.Country?.Name;
            _cities = string.Join(", ", Station?.StationCities?.Select(x => x.City?.Name)
            .Where(x => !string.IsNullOrEmpty(x)) ?? Array.Empty<string>());
            _genres = string.Join(", ", Station?.StationGenres?.Select(x => x.Genre?.Name)
            .Where(x => !string.IsNullOrEmpty(x)) ?? Array.Empty<string>());
            _subgenres = string.Join(", ", Station?.StationSubGenres?.Select(x => x.SubGenre?.Name)
            .Where(x => !string.IsNullOrEmpty(x)) ?? Array.Empty<string>());
            StateHasChanged();
        }

        await base.OnParametersSetAsync();
    }

    private async Task Play()
    {
        _isPlaying = !_isPlaying;
        await JSRuntime.InvokeVoidAsync("playAudio", _isPlaying);
    }

    private async Task SetVolume(double volume)
    {
        _volume = 1.0 - volume;
        await JSRuntime.InvokeVoidAsync("setVolume", _volume);
    }

    private async Task ShowMessage()
    {
        if (Station != null)
        {
            var message = $"{localizer["StreamNotAvailable"]}: {Station.Name} ({AudioUrl})";
            toastService.ShowError(message);
            _isPlaying = false;
            await JSRuntime.InvokeVoidAsync("playAudio", _isPlaying);
        }
    }

    private void ToggleFavorite()
    {
        if (Station != null)
        {
            Station.IsFavorite = !Station.IsFavorite;
            stations.SetFavorite(Station.Id, Station.IsFavorite);
            appStateService.FavoriteStation = new FavoriteStation
            {
                StationId = Station.Id,
                IsFavorite = Station.IsFavorite
            };
        }
    }

    private void Search()
    {
        if (!string.IsNullOrWhiteSpace(SearchText))
        {
            var searchUrl = string.Format(options.Value.TrackSearchUrl, System.Web.HttpUtility.UrlEncode(SearchText));
            linkOpeningService.OpenUrl(searchUrl);
        }
    }

    [JSInvokable]
    public async Task<string> Ping(string name)
    {
        if (!httpClient.DefaultRequestHeaders.Contains(FileDownloadService.USER_AGENT_HEADER_NAME))
        {
            httpClient.DefaultRequestHeaders.Add(FileDownloadService.USER_AGENT_HEADER_NAME, FileDownloadService.USER_AGENT);
        }

        try
        {
            if (!string.IsNullOrEmpty(name))
            {
                var url = string.Format(options.Value.CurrentTrackInfoUrl, name);
                var response = await httpClient.GetAsync(url);
                if (response.IsSuccessStatusCode)
                {
                    var stream = await response.Content.ReadAsStreamAsync();
                    var currentTrack = await System.Text.Json.JsonSerializer.DeserializeAsync<CurrentTrack>(stream);
                    if (currentTrack != null)
                    {
                        SearchText = $"{currentTrack.Artist} - {currentTrack.Title}";
                        if (Station != null && (!string.IsNullOrEmpty(currentTrack.Artist) || !string.IsNullOrEmpty(currentTrack.Title)))
                        {
                            var record = new HistoryRecord
                            {
                                StartTime = currentTrack.DateTime,
                                StationName = Station.Name,
                                TrackName = SearchText
                            };
                            if (!historyRecordEqualityComparer.Equals(appStateService.LastHistoryRecord, record))
                            {
                                await historyRecords.AddAsync(record);
                                appStateService.LastHistoryRecord = record;
                            }
                        }
                        return SearchText;
                    }
                }
            }

            SearchText = string.Empty;
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine(ex.Message);
            SearchText = string.Empty;
        }

        return SearchText;
    }

    public void Dispose() => thisRef?.Dispose();

    public class CurrentTrack
    {
        [JsonPropertyName("artist")]
        public string Artist { get; set; } = string.Empty;
        [JsonPropertyName("title")]
        public string Title { get; set; } = string.Empty;
        [JsonPropertyName("time")]
        public string TimeString { get; set; } = string.Empty;
        [JsonPropertyName("date")]
        public string DateString { get; set; } = string.Empty;
        public DateTime DateTime
        {
            get
            {
                if (DateTime.TryParseExact(
                $"{DateString} {TimeString}",
                "yyyy-MM-dd HH:mm:ss",
                CultureInfo.InvariantCulture,
                DateTimeStyles.None,
                out DateTime result))
                {
                    return result;
                }

                return DateTime.Now;
            }
        }
    }
}